# Инструкция для разработчиков (*и LLM...*)

Данная страница предназначена для ознакомления разработчиков с огранизацией процесса разработки проекта.

## Структура проекта

```
├── apps
│   ├── client                # компонент для визуализации для пользователей
│   ├── api                   # пока отсутствует, но будет (на базе DRF)
│   ├── common                # компонент с общей для всех остальных компонентов бизнес-логики
│   │   ├── tests/            # юнит-тесты через pytest
│   │   ├── services/         # бизнес-логика проекта (произвольная архитектура, независимая от веба)
│   │   ├   ...
│   │   ├── models.py         # общие для всех компонентов модели
│   │   └── views.py          # не используется в common
│   └── panel                 # компонент для панели управления всем проектом
│       ├── tasks             # повторяемые задачи через celery-beat
│       │   └── __init__.py
│       ├   ...
│       └── views.py 
├── docs/                    # документация
├── vstu_schedule/           # главные настройки Django проекта
├── manage.py
└── pyproject.toml           # настройка проекта + его зависимости вместо requirements.txt
```

Этот проект предназначен для предоставления нового, интерактивного расписания ВУЗа, на основе "сырых" Excel файлов, содержащих расписания занятий для набора групп. Поскольку, проект требует сразу нескольких компонентов (Redis, PostgreSQL, запуск Celery), его лучше запускать в Docker через compose.

Ключевыми особенностями данного проекта являются:

- веб-визуализация расписания с интерактивными фильтрами и сортировкой для групп/преподавателей (готовая для внедрения в виде `iframe`)
- поддержка REST API для получения расписаний (в формате JSON, с аутентификацией по токенам)
- панель управления проектом (автообновление расписаний, ручные корректировки расписаний, архив расписаний) с авторизацией для защиты

![Концептуальная диаграмма компонентов приложения](attachments/components.png)
*Замечание: данная диаграмма не отражает архитектуры именно Django-проекта, а нужна для концептуального представления проекта*

Проект использует модульность Django за счет встроенной концепции приложений. Приложение `common` объединяет в себе разделяемые компоненты всего проекта, и не может иметь views.
Прежде всего, это приложение хранит слой бизнес-логики, разделяемые модели, и в действительности представляет собой библиотеку для других приложений проекта

Слой бизнес логики, определяемый в папке `services` приложения `common` имеет произвольную архитектуру, но с соблюдением указанных в правилах принципах проектирования. Разрешается определять `services` и в других приложениях, по аналогии с `common`, но стоит учитывать, что такая бизнес-логика должна предназначаться только для этого приложения и не может быть разделяемой

> В других приложениях допустимо "схлопывать" папку `services/` в один файл `services.py`, если бизнес-логика не обширная

Для данного проекта решено разрешить использование моделей Django в бизнес-логике. Но запрещается прописывать (особенно сложную) бизнес-логику в класс модели, хоть он это и позволяет сделать! (антипаттерн "fat models").
В случаях, когда необходимо производить по заданным условиям выборку из БД для дальнейшей передачи в слой бизнес логики или возможности переиспользования в других views, во многих проектах используют подход с селекторами - функциями с осмысленными названиями, которые выполняют чтение из БД по заданным условиям и возвращают `QuerySet`. Они определяются в корне приложения в папке `selectors.py`. В данном проекте, это также допустимая и рекомендуемая практика.

> Слой бизнес-логики желательно реализовывать с заделом на будущее - с возможностью в дальнейшем вынести его из-под Django приложения, но это не накладывает запрет на использованией ORM моделей Django (для избежания усложнения) и является, скорее, архитектурным ориентиром, а не требованием.

## Техническая часть

Базовая версия Python (минимально поддерживаемая) - **3.13** (см. файл [.python-version](../.python-version))
Для управления локальной сборкой и зависимостями используется пакетный менеджер `uv`

Используется Django 6.x для бэкенда, Celery Beat - для периодически запускаемых задач, которые автоматизируют выполнение задач (например, скачивание или обновление исходных файлов расписаний).
Код Django-проекта в целом является синхронным (кроме фоновых задач), и не требует полного перевода на асинхронность вследствие недостаточной поддержки со стороны Django. Однако некоторые фрагменты кода (например, скачивание из Интернета) могут использовать распараллеливание или асинхронность в разумных пределах, если это не вредит основному проекту или сторонним серверам (например, серверу ВУЗа)

Основой разбора Excel-файлов является библиотека [собственной разработки, специализирующаяся на двумерных грамматиках](https://github.com/den1s0v/vstu_xls), подключаемая как зависимость pip.

Для реализации REST API будет использован Django REST Framework (DRF).
HTML-код будет визуализирован с помощью **шаблонов Django**, однако использование JS не запрещено, и по мере необходимости может быть развернут npm-проект в корневой папке `js` (для использования React или других сложных клиентских библиотек), но с важными ограничениями:

- Данный npm проект (или, возможно в будущем, несколько проектов) должен собираться в standalone js- и css-файлы и легко подключаться к шаблону Django / или просто HTML файлу из папки `templates` (у конкретного приложения или в корне проекта)
- В шаблонах Django / HTML файлах не должны использовать нелокальные файлы библиотек/стилей. Т.е. подключаемые из cdn-серверов, unpkg и прочих подобных ресурсов -> это лишает проект автономности

## Правила работы с репозиторием

*применяются при code review pull-request*

1. Все изменения в репозиторий попадают только через pull request в ветку main (PR могут быть размещены как в этом репозитории (другая ветка), так и в форках, но конечные изменения попадают в main ветку). Pull-request должен содержать информацию о добавляемых изменениях
2. Сложная функциональность бизнес-логики должна быть покрыта тестами `pytest` (но не непосредственное тестирование фрагментов подключаемого кода, например библиотеки `vstu-xls`)
3. В случае описания собственных схем данных (JSON, XML и т.п.), они должны быть снабжены соответствующими схемами (JSON Schema, например), чтобы мы могли проверить формат данных на корректность и согласованность. В случае, если генерация формата данных лежит на библиотеке (например, `serializers` в DRF) и она может проверить валидность данных, то схема не требуется
4. Никакие секретные данные (например, токены) или данные, не относящиеся к проекту, не должны попадать в репозиторий
5. Синтаксические особенности кода должны соответствовать минимально поддерживаемой версии Python (см. выше)
6. Сторонние зависимости, включаемые в проект впервые или обновление текущих (до мажорных версий с breaking changes, если прошлая версия еще поддерживается), должны быть обоснованны разработчиком в PR. Мы не стремимся к добавлению плохо поддерживаемых/уязвимых библиотек в код проекта
7. Код Python должен быть написан в соответствии с принципами PEP8, SOLID, DRY, KISS и с учетом современных возможностей языка в минимально поддерживаемой версии языка
8. Обязательным является использование аннотаций типов в коде (с учётом, что `typing.List`, ..., `typing.Optional` уже устарели, см. пункт 7), а также крайне желательно использование линтера (крайне рекомендуется `ruff`) и type-checker (рекомендуется pyright, mypy) для успешного прохождения code review
9. Для публичных тестов крайне желательно использовать данные с нереальным содержимым (а не конкретные расписания ВУЗа)
10. Работоспособность существующих функций проекта не должна быть сломана в новом PR, если она существенно меняется - об этом нужно сообщить в тексте PR. Проверка работоспособности проекта после изменений необходима!
11. Приветствуются однострочные опорные комментарии и небольшие docstring, не засоряющие код, объясняющие работу нетривиального кода для новых разработчиков (влияет на code review)
12. Новая сложная логика/алгоритмы, которая слишком объемна для описания в коде, должна описываться в корневой папке `docs` в файле формата Markdown, а в соответствующем коде (docstring/комментарии) должно быть указание на этот файл
13. Крайне нежелательно, чтобы изменения в проекте требовали выполнения отдельных sql-скриптов, миграции должны покрывать все потребности в изменении данных
14. Рекомендуется для бизнес-логики вводить логирование встроенными средствами Python (через `logging`, конфигурация уже в `settings.py`)
15. В PR избавляемся от лишних файлов, созданных LLM-агентами. Крайне рекомендуется перепроверять результаты работы ИИ вручную!
16. В Django для создания endpoint'ов используется views. При работе с ними следует помнить:

    16.1. группы взаимосвязанных view лучше определять в отдельном файле и импортировать их в основной `views.py` приложения

    16.2. во view не должна реализовываться сложная и особенно разделяемая с другими компонентами логика, для этого предназначена папка `services/` в приложении `common` или в текущем приложении

> В идеальной ситуации, во view должно остаться только то, что касается HTTP и веба

## Нюансы работы с Docker

В compose-файле определена привязка репозитория к папке проекта внутри контейнера. Этот приём позволяет обновлять код внутри контейнера без пересборки образа.

```yaml
 web:
    build: .
    image: vstu_schedule:latest 
    volumes:
      - .:/app # <--- привязыка корневого каталога проекта
```

Однако, у этого подхода есть ограничения:

- Новые локально добавленные зависимости не будут установлены в контейнер без пересборки образа (`docker compose build` или `docker compose up -d --build`), либо без прямой установки зависимости внутри контейнера (работает до `compose down`)
- Celery не обновляется, следовательно новые задачи не будут видны без пересборки образов `worker` и `beat`

Данную привязку следует убрать при запуске в производственном режиме (production), но в репозитории она не должна исчезнуть
При необходимости, можно открыть базу данных Postgres при локальной разработке (чтобы добавить, например её, в pgAdmin) через указание проброса портов в `docker-compose.yml`

> [!note] Локальный режим
>
> Стоит отметить, что запуск проекта в локальном режиме (без Docker) по-прежнему возможен, но требует наличия доступной PostgreSQL базы локально или удалённо, и ручного запуска Celery, если он нужен, или переменной `DISABLE_CELERY=1` в `.env.local` для его частичного отключения (чтобы приложение смогло запуститься без Redis)



# Начало работы

Установить `uv` --- быстрый менеджер проектов и пакетов для Python (на Windows): `powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"`

Установка пакетов  (аналог `pip install -r requirements.txt`):

```bash
uv sync
```

Скопировать `.env.example` в `.env`, при необходимости отредактировать.

Запустить проект (см. выше):
```bash
docker compose up -d --build
```
это поднимет контейнер, развернёт внутри PostgreSQL и создаст БД для неё, а также Redis и Celery.


